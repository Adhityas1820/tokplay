<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="TokPlay">
<title>TokPlay</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,300;9..40,500;9..40,700&family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
:root{
  --bg:#0a0a0c;--surface:#141418;--surface2:#1c1c22;--surface3:#24242c;
  --accent:#fe2c55;--accent2:#25f4ee;--accent-glow:rgba(254,44,85,.25);
  --text:#f0f0f2;--text2:#8e8e9a;--text3:#55555f;
  --radius:16px;
  --safe-top:env(safe-area-inset-top,20px);
  --safe-bottom:env(safe-area-inset-bottom,20px);
}
html,body{
  height:100%;width:100%;overflow:hidden;
  font-family:'DM Sans',sans-serif;
  background:var(--bg);color:var(--text);
  -webkit-user-select:none;user-select:none;
}
#app{
  height:100%;display:flex;flex-direction:column;
  padding-top:var(--safe-top);padding-bottom:var(--safe-bottom);
  position:relative;overflow:hidden;
}
.ambient{
  position:fixed;top:-40%;left:-20%;width:140%;height:80%;
  background:radial-gradient(ellipse at 50% 80%,var(--accent-glow) 0%,transparent 60%);
  pointer-events:none;z-index:0;opacity:0;transition:opacity 1.2s ease;
}
.ambient.playing{opacity:1}

.header{
  display:flex;align-items:center;justify-content:space-between;
  padding:12px 20px 8px;position:relative;z-index:10;flex-shrink:0;
}
.logo{
  font-family:'Outfit',sans-serif;font-weight:800;font-size:22px;
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;
  letter-spacing:-.5px;
}
.header-actions{display:flex;gap:8px}
.icon-btn{
  width:40px;height:40px;border-radius:12px;
  background:var(--surface);border:1px solid var(--surface3);
  display:flex;align-items:center;justify-content:center;
  cursor:pointer;color:var(--text2);transition:all .2s;
}
.icon-btn:active{transform:scale(.92);background:var(--surface2)}
.icon-btn svg{width:20px;height:20px}

.action-bar{
  display:flex;gap:8px;padding:0 20px 10px;
  position:relative;z-index:10;flex-shrink:0;
}
.action-btn{
  flex:1;display:flex;align-items:center;justify-content:center;gap:8px;
  padding:14px 12px;border-radius:14px;border:none;
  font-family:inherit;font-size:13px;font-weight:600;
  cursor:pointer;transition:all .2s;
}
.action-btn:active{transform:scale(.97)}
.action-btn.primary{background:linear-gradient(135deg,var(--accent),#ff4470);color:white}
.action-btn.secondary{background:var(--surface);border:1px solid var(--surface3);color:var(--text2)}
.action-btn svg{width:18px;height:18px;flex-shrink:0}

/* Toast */
.toast{
  position:fixed;top:calc(var(--safe-top) + 60px);left:50%;transform:translateX(-50%) translateY(-20px);
  background:var(--surface2);border:1px solid var(--surface3);
  color:var(--text);font-size:13px;font-weight:500;
  padding:10px 20px;border-radius:12px;z-index:300;
  opacity:0;transition:all .3s ease;pointer-events:none;white-space:nowrap;
}
.toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
.toast.success{border-color:rgba(37,244,238,.3)}
.toast.error{border-color:rgba(254,44,85,.3)}

/* Processing overlay - for downloads only */
.processing-overlay{
  display:none;position:fixed;inset:0;z-index:200;
  background:rgba(0,0,0,.85);backdrop-filter:blur(8px);
  flex-direction:column;align-items:center;justify-content:center;gap:16px;
}
.processing-overlay.show{display:flex}
.spinner{width:44px;height:44px;border:3px solid var(--surface3);border-top-color:var(--accent);border-radius:50%;animation:spin .8s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.processing-text{font-size:15px;font-weight:600;color:var(--text)}
.processing-detail{font-size:12px;color:var(--text3);text-align:center;max-width:260px}

/* Playlist */
.playlist-section{flex:1;overflow:hidden;display:flex;flex-direction:column;position:relative;z-index:10}
.playlist-header{display:flex;align-items:center;justify-content:space-between;padding:4px 20px 8px;flex-shrink:0}
.playlist-title{font-family:'Outfit',sans-serif;font-weight:600;font-size:16px;color:var(--text2)}
.track-count{font-size:12px;color:var(--text3);background:var(--surface);padding:4px 10px;border-radius:20px}
.clear-btn{font-size:12px;color:var(--accent);background:none;border:none;cursor:pointer;padding:4px 10px;font-family:inherit}

.tracks-list{flex:1;overflow-y:auto;padding:0 20px 12px;-webkit-overflow-scrolling:touch}
.tracks-list::-webkit-scrollbar{display:none}

.track-item{
  display:flex;align-items:center;gap:12px;
  padding:12px 14px;margin-bottom:8px;
  background:var(--surface);border-radius:14px;
  border:1px solid transparent;transition:all .25s;cursor:pointer;
}
.track-item.active{
  border-color:var(--accent);
  background:linear-gradient(135deg,rgba(254,44,85,.08),rgba(37,244,238,.04));
  box-shadow:0 4px 24px rgba(254,44,85,.12);
}
.track-item:active{transform:scale(.98)}
.track-num{
  width:28px;height:28px;border-radius:8px;background:var(--surface2);
  display:flex;align-items:center;justify-content:center;
  font-size:12px;font-weight:600;color:var(--text3);flex-shrink:0;
}
.track-item.active .track-num{background:var(--accent);color:white}
.track-info{flex:1;min-width:0}
.track-name{font-size:14px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.track-name-input{background:none;border:none;color:var(--text);font-size:14px;font-weight:500;font-family:inherit;width:100%;outline:none;padding:0}
.track-duration{font-size:11px;color:var(--text3);margin-top:2px}
.track-actions{display:flex;gap:4px;flex-shrink:0}
.track-btn{
  width:32px;height:32px;border-radius:8px;background:var(--surface2);
  border:none;display:flex;align-items:center;justify-content:center;
  cursor:pointer;color:var(--text3);transition:all .2s;
}
.track-btn:active{transform:scale(.88)}
.track-btn.delete:active{color:var(--accent)}
.track-btn svg{width:14px;height:14px}
.trim-badge{display:inline-block;font-size:9px;color:var(--accent2);background:rgba(37,244,238,.1);padding:1px 6px;border-radius:4px;margin-left:4px;vertical-align:middle}

.empty-state{text-align:center;padding:40px 20px;color:var(--text3)}
.empty-state svg{width:48px;height:48px;margin-bottom:12px;opacity:.4}
.empty-state p{font-size:14px;line-height:1.5}
.empty-state .hint{font-size:11px;margin-top:8px;opacity:.7}

/* Player */
.now-playing{flex-shrink:0;position:relative;z-index:10;padding:0 20px 8px}
.player-card{
  background:var(--surface);border-radius:20px;border:1px solid var(--surface3);
  padding:16px 18px 14px;box-shadow:0 -8px 40px rgba(0,0,0,.4);
}
.progress-row{display:flex;align-items:center;gap:8px;margin-bottom:12px}
.progress-time{font-size:10px;color:var(--text3);min-width:32px;font-variant-numeric:tabular-nums}
.progress-bar{flex:1;height:4px;background:var(--surface3);border-radius:2px;cursor:pointer;position:relative;overflow:hidden}
.progress-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));border-radius:2px;width:0%;transition:width .3s linear}
.now-info{display:flex;align-items:center;gap:12px;margin-bottom:14px}
.now-art{
  width:44px;height:44px;border-radius:12px;flex-shrink:0;
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;
}
.now-art svg{width:20px;height:20px;color:white}
.now-art .disc{position:absolute;inset:0;border:3px solid rgba(255,255,255,.15);border-radius:12px}
.now-art.spinning .disc{animation:spin 3s linear infinite}
.now-meta{flex:1;min-width:0}
.now-title{font-size:14px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.now-status{font-size:11px;color:var(--text3);margin-top:1px}
.controls{display:flex;align-items:center;justify-content:center;gap:16px}
.ctrl-btn{
  width:44px;height:44px;border-radius:50%;background:var(--surface2);
  border:none;display:flex;align-items:center;justify-content:center;
  cursor:pointer;color:var(--text);transition:all .2s;
}
.ctrl-btn:active{transform:scale(.88)}
.ctrl-btn svg{width:20px;height:20px}
.ctrl-btn.play{width:56px;height:56px;background:linear-gradient(135deg,var(--accent),#ff4470);box-shadow:0 4px 20px var(--accent-glow)}
.ctrl-btn.play svg{width:24px;height:24px;color:white}

.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:100;display:none;align-items:flex-end;justify-content:center;backdrop-filter:blur(4px)}
.modal-overlay.show{display:flex}
.modal{width:100%;max-width:420px;background:var(--surface);border-radius:24px 24px 0 0;padding:20px 20px calc(20px + var(--safe-bottom));max-height:70vh}
.modal-handle{width:36px;height:4px;background:var(--surface3);border-radius:2px;margin:0 auto 16px}
.modal h3{font-family:'Outfit',sans-serif;font-size:18px;margin-bottom:16px}
.modal-btn{width:100%;padding:14px;border-radius:14px;border:none;font-family:inherit;font-size:15px;font-weight:600;cursor:pointer;margin-bottom:8px;transition:all .2s}
.modal-btn:active{transform:scale(.97)}
.modal-btn.danger{background:rgba(254,44,85,.15);color:var(--accent)}
.modal-btn.cancel{background:var(--surface2);color:var(--text2)}

::-webkit-scrollbar{width:0}
#fileInput,#libraryInput{display:none}
@keyframes fadeUp{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}
.track-item{animation:fadeUp .3s ease both}
</style>
</head>
<body>
<div id="app">
  <div class="ambient" id="ambient"></div>

  <div class="header">
    <div class="logo">TokPlay</div>
    <div class="header-actions">
      <div class="icon-btn" onclick="downloadAllTrimmed()" title="Download all trimmed">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
      </div>
    </div>
  </div>

  <div class="action-bar">
    <button class="action-btn primary" onclick="document.getElementById('fileInput').click()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
      Upload TikToks
    </button>
    <button class="action-btn secondary" onclick="document.getElementById('libraryInput').click()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
      Load Library
    </button>
  </div>

  <input type="file" id="fileInput" accept="video/*,.mp4,.mov,.webm,.mp3,.m4a,.wav" multiple>
  <input type="file" id="libraryInput" accept="audio/*,.wav,.mp3,.m4a,.ogg,.webm" multiple>

  <div class="playlist-section">
    <div class="playlist-header">
      <div class="playlist-title">Playlist</div>
      <span class="track-count" id="trackCount">0 tracks</span>
      <button class="clear-btn" onclick="showClearModal()">Clear All</button>
    </div>
    <div class="tracks-list" id="tracksList"></div>
  </div>

  <div class="now-playing">
    <div class="player-card">
      <div class="progress-row">
        <span class="progress-time" id="currentTime">0:00</span>
        <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
        <span class="progress-time" id="totalTime">0:00</span>
      </div>
      <div class="now-info">
        <div class="now-art" id="nowArt">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="18" cy="16" r="3" fill="none" stroke="currentColor" stroke-width="2"/></svg>
          <div class="disc"></div>
        </div>
        <div class="now-meta">
          <div class="now-title" id="nowTitle">No track selected</div>
          <div class="now-status" id="nowStatus">Upload videos to begin</div>
        </div>
      </div>
      <div class="controls">
        <button class="ctrl-btn" onclick="prevTrack()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 20L9 12l10-8v16z"/><rect x="5" y="4" width="2" height="16"/></svg></button>
        <button class="ctrl-btn play" id="playBtn" onclick="togglePlay()"><svg viewBox="0 0 24 24" fill="currentColor" id="playIcon"><polygon points="6,3 20,12 6,21"/></svg></button>
        <button class="ctrl-btn" onclick="nextTrack()"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M5 4l10 8-10 8V4z"/><rect x="17" y="4" width="2" height="16"/></svg></button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="clearModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3>Clear Playlist?</h3>
      <p style="color:var(--text2);font-size:14px;margin-bottom:20px">Removes all tracks from the app. Your TokPlay_ files in Downloads are safe.</p>
      <button class="modal-btn danger" onclick="clearPlaylist()">Clear All Tracks</button>
      <button class="modal-btn cancel" onclick="hideClearModal()">Cancel</button>
    </div>
  </div>

  <div class="processing-overlay" id="processingOverlay">
    <div class="spinner"></div>
    <div class="processing-text" id="processingText">Preparing download...</div>
    <div class="processing-detail" id="processingDetail">Encoding trimmed audio</div>
  </div>

  <div class="toast" id="toast"></div>
</div>

<script>
// ─── State ───
let tracks = [];
let currentIndex = -1;
let isPlaying = false;
const audio = new Audio();
const TRIM_SECONDS = 4;
const DB_NAME = 'TokPlayDB';
const DB_VERSION = 1;
const STORE_NAME = 'tracks';

// ─── IndexedDB ───
function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { keyPath: 'id' });
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function dbSave(track) {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    tx.objectStore(STORE_NAME).put({ id: track.id, name: track.name, blob: track.originalBlob || track.blob, duration: track.fullDuration, trimmedDuration: track.duration });
    tx.oncomplete = res; tx.onerror = () => rej(tx.error);
  });
}
async function dbDelete(id) {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    tx.objectStore(STORE_NAME).delete(id); tx.oncomplete = res; tx.onerror = () => rej(tx.error);
  });
}
async function dbClear() {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    tx.objectStore(STORE_NAME).clear(); tx.oncomplete = res; tx.onerror = () => rej(tx.error);
  });
}
async function dbLoadAll() {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const req = tx.objectStore(STORE_NAME).getAll();
    req.onsuccess = () => res(req.result); req.onerror = () => rej(req.error);
  });
}
async function dbSaveMeta() {
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    tx.objectStore(STORE_NAME).put({ id: '__meta__', order: tracks.map(t => t.id), currentIndex });
    tx.oncomplete = res; tx.onerror = () => rej(tx.error);
  });
}

// ─── Unique ID ───
function uid() { return (crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(36) + Math.random().toString(36).slice(2)); }

// ─── Get duration from a blob URL ───
function getDuration(url) {
  return new Promise(resolve => {
    const a = new Audio();
    a.preload = 'metadata';
    a.src = url;
    a.addEventListener('loadedmetadata', () => resolve(a.duration));
    a.addEventListener('error', () => resolve(0));
    // iOS sometimes needs a nudge
    setTimeout(() => { if (!a.duration) resolve(0); }, 3000);
  });
}

// ─── Toast ───
let toastTimer;
function showToast(msg, type='success') {
  const t = document.getElementById('toast');
  t.textContent = msg; t.className = 'toast show ' + type;
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => t.className = 'toast', 2500);
}

// ─── Upload TikToks (instant — no processing, trim at playback) ───
document.getElementById('fileInput').addEventListener('change', async e => {
  const files = Array.from(e.target.files);
  if (!files.length) return;

  let added = 0;
  for (const file of files) {
    const name = file.name.replace(/\.[^.]+$/, '').replace(/[-_]/g, ' ');
    const id = uid();
    const blob = file;
    const url = URL.createObjectURL(blob);
    const fullDuration = await getDuration(url);
    const trimmedDuration = Math.max(fullDuration - TRIM_SECONDS, 1);

    const track = { id, name, blob, originalBlob: blob, url, fullDuration, duration: trimmedDuration };
    tracks.push(track);
    await dbSave(track);
    added++;
  }

  renderTracks();
  if (currentIndex === -1 && tracks.length > 0) loadTrack(0, false);
  await dbSaveMeta();
  showToast(`Added ${added} track${added > 1 ? 's' : ''} — last ${TRIM_SECONDS}s auto-trimmed`, 'success');
  e.target.value = '';
});

// ─── Load Library (pre-trimmed files from Downloads) ───
document.getElementById('libraryInput').addEventListener('change', async e => {
  const files = Array.from(e.target.files);
  if (!files.length) return;

  let added = 0;
  for (const file of files) {
    const name = file.name.replace(/\.[^.]+$/, '').replace(/^TokPlay_/, '').replace(/[-_]/g, ' ');
    const id = uid();
    const blob = file;
    const url = URL.createObjectURL(blob);
    const dur = await getDuration(url);

    // Library files are already trimmed, so no additional trim
    const track = { id, name, blob, originalBlob: blob, url, fullDuration: dur, duration: dur, fromLibrary: true };
    tracks.push(track);
    await dbSave(track);
    added++;
  }

  renderTracks();
  if (currentIndex === -1 && tracks.length > 0) loadTrack(0, false);
  await dbSaveMeta();
  showToast(`Loaded ${added} track${added > 1 ? 's' : ''} from library`, 'success');
  e.target.value = '';
});

// ─── Render ───
function renderTracks() {
  const list = document.getElementById('tracksList');
  document.getElementById('trackCount').textContent = `${tracks.length} track${tracks.length !== 1 ? 's' : ''}`;

  if (!tracks.length) {
    list.innerHTML = `<div class="empty-state">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><circle cx="12" cy="12" r="10"/><path d="M9 12l2 2 4-4"/></svg>
      <p>Upload TikTok videos to get started</p>
      <p class="hint">Last ${TRIM_SECONDS}s trimmed automatically during playback.<br>Download tracks to save as TokPlay_ files.</p>
    </div>`;
    return;
  }

  list.innerHTML = tracks.map((t, i) => `
    <div class="track-item ${i===currentIndex?'active':''}" onclick="loadTrack(${i},true)" style="animation-delay:${i*.04}s">
      <div class="track-num">${i===currentIndex?'▶':i+1}</div>
      <div class="track-info">
        <div class="track-name" id="tn-${i}">${esc(t.name)}${t.fromLibrary?'':'<span class="trim-badge">-'+TRIM_SECONDS+'s</span>'}</div>
        <div class="track-duration">${fmt(t.duration)}</div>
      </div>
      <div class="track-actions">
        <button class="track-btn" onclick="editName(${i},event)" title="Rename">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
        </button>
        <button class="track-btn" onclick="downloadOne(${i},event)" title="Download">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
        </button>
        <button class="track-btn delete" onclick="deleteTrack(${i},event)" title="Delete">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/></svg>
        </button>
      </div>
    </div>`).join('');
}

function esc(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;')}

// ─── Playback (trim happens here — just stop 4s early) ───
let trimCheckInterval = null;

function loadTrack(index, autoplay) {
  if (index < 0 || index >= tracks.length) return;
  currentIndex = index;
  const track = tracks[index];
  if (!track.url && track.blob) track.url = URL.createObjectURL(track.blob);

  audio.src = track.url;
  audio.load();
  document.getElementById('nowTitle').textContent = track.name;
  document.getElementById('nowStatus').textContent = `Track ${index + 1} of ${tracks.length}`;
  renderTracks();
  dbSaveMeta();

  if (autoplay) audio.play().then(() => { isPlaying = true; updatePlayBtn(); }).catch(()=>{});
}

function togglePlay() {
  if (!tracks.length) return;
  if (currentIndex === -1) { loadTrack(0, true); return; }
  if (isPlaying) { audio.pause(); isPlaying = false; }
  else audio.play().then(() => { isPlaying = true; }).catch(()=>{});
  updatePlayBtn();
}

function updatePlayBtn() {
  const icon = document.getElementById('playIcon');
  const art = document.getElementById('nowArt');
  const amb = document.getElementById('ambient');
  if (isPlaying) {
    icon.innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
    art.classList.add('spinning'); amb.classList.add('playing');
  } else {
    icon.innerHTML = '<polygon points="6,3 20,12 6,21"/>';
    art.classList.remove('spinning'); amb.classList.remove('playing');
  }
}

function nextTrack() { if (tracks.length) loadTrack((currentIndex+1)%tracks.length, true); }
function prevTrack() {
  if (!tracks.length) return;
  if (audio.currentTime > 3) { audio.currentTime = 0; return; }
  loadTrack((currentIndex-1+tracks.length)%tracks.length, true);
}

audio.addEventListener('ended', () => nextTrack());
audio.addEventListener('pause', () => { isPlaying = false; updatePlayBtn(); });
audio.addEventListener('play', () => {
  isPlaying = true; updatePlayBtn();
  if ('mediaSession' in navigator && tracks[currentIndex]) {
    navigator.mediaSession.metadata = new MediaMetadata({ title: tracks[currentIndex].name, artist: 'TokPlay', album: 'TikTok Audio' });
  }
});

// Trim during playback: when we reach (fullDuration - TRIM_SECONDS), skip to next
audio.addEventListener('timeupdate', () => {
  const track = tracks[currentIndex];
  if (!track || !audio.duration) return;

  // If not from library, enforce trim
  if (!track.fromLibrary && track.fullDuration > TRIM_SECONDS) {
    const trimPoint = track.fullDuration - TRIM_SECONDS;
    if (audio.currentTime >= trimPoint) {
      nextTrack();
      return;
    }
  }

  const effectiveDuration = track.duration;
  const pct = Math.min((audio.currentTime / effectiveDuration) * 100, 100);
  document.getElementById('progressFill').style.width = pct + '%';
  document.getElementById('currentTime').textContent = fmt(audio.currentTime);
  document.getElementById('totalTime').textContent = fmt(effectiveDuration);
});

document.getElementById('progressBar').addEventListener('click', e => {
  const track = tracks[currentIndex];
  if (!track || !audio.duration) return;
  const r = e.currentTarget.getBoundingClientRect();
  const pct = (e.clientX - r.left) / r.width;
  audio.currentTime = pct * track.duration;
});

// ─── Track Management ───
function editName(i, e) {
  e.stopPropagation();
  const el = document.getElementById(`tn-${i}`);
  el.innerHTML = `<input class="track-name-input" value="${esc(tracks[i].name)}" onblur="saveName(${i},this)" onkeydown="if(event.key==='Enter')this.blur()" autofocus>`;
  el.querySelector('input').focus(); el.querySelector('input').select();
}
function saveName(i, input) {
  tracks[i].name = input.value.trim() || tracks[i].name;
  if (i === currentIndex) document.getElementById('nowTitle').textContent = tracks[i].name;
  dbSave(tracks[i]); renderTracks();
}

// ─── Download (encode trimmed WAV on demand) ───
async function trimAndEncode(track) {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  if (ctx.state === 'suspended') await ctx.resume();
  const buf = await track.blob.arrayBuffer();
  const decoded = await ctx.decodeAudioData(buf);

  const sr = decoded.sampleRate;
  const ch = decoded.numberOfChannels;
  const total = decoded.length;
  const trimSamples = track.fromLibrary ? 0 : Math.min(TRIM_SECONDS * sr, total - sr);
  const newLen = Math.max(total - trimSamples, sr);

  const trimmed = ctx.createBuffer(ch, newLen, sr);
  for (let c = 0; c < ch; c++) {
    const s = decoded.getChannelData(c), d = trimmed.getChannelData(c);
    for (let i = 0; i < newLen; i++) d[i] = s[i];
  }
  ctx.close();
  return encodeWav(trimmed);
}

function encodeWav(buffer) {
  const ch = buffer.numberOfChannels, sr = buffer.sampleRate, bits = 16;
  let inter;
  if (ch === 2) {
    const L = buffer.getChannelData(0), R = buffer.getChannelData(1);
    inter = new Float32Array(L.length * 2);
    for (let i = 0; i < L.length; i++) { inter[i*2]=L[i]; inter[i*2+1]=R[i]; }
  } else inter = buffer.getChannelData(0);
  const dLen = inter.length * 2, buf = new ArrayBuffer(44+dLen), v = new DataView(buf);
  const w=(o,s)=>{for(let i=0;i<s.length;i++)v.setUint8(o+i,s.charCodeAt(i))};
  w(0,'RIFF');v.setUint32(4,36+dLen,true);w(8,'WAVE');w(12,'fmt ');
  v.setUint32(16,16,true);v.setUint16(20,1,true);v.setUint16(22,ch,true);
  v.setUint32(24,sr,true);v.setUint32(28,sr*ch*2,true);v.setUint16(32,ch*2,true);
  v.setUint16(34,bits,true);w(36,'data');v.setUint32(40,dLen,true);
  let off=44;
  for(let i=0;i<inter.length;i++){let s=Math.max(-1,Math.min(1,inter[i]));v.setInt16(off,s<0?s*0x8000:s*0x7FFF,true);off+=2}
  return new Blob([buf],{type:'audio/wav'});
}

function dlBlob(blob, name) {
  const u = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=u; a.download=name;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  setTimeout(()=>URL.revokeObjectURL(u),5000);
}

function sanitize(n){return n.replace(/[^a-zA-Z0-9_\- ]/g,'').replace(/\s+/g,'_').substring(0,60)}

async function downloadOne(i, e) {
  e.stopPropagation();
  const t = tracks[i];
  showProc('Preparing download...');
  try {
    const wav = await trimAndEncode(t);
    dlBlob(wav, 'TokPlay_' + sanitize(t.name) + '.wav');
    showToast('Saved to Downloads', 'success');
  } catch(err) {
    console.error(err);
    // Fallback: download original
    dlBlob(t.blob, 'TokPlay_' + sanitize(t.name) + '.original' + (t.blob.type.includes('mp4')?'.mp4':'.wav'));
    showToast('Saved original (trim failed)', 'error');
  }
  hideProc();
}

async function downloadAllTrimmed() {
  if (!tracks.length) { showToast('No tracks', 'error'); return; }
  showProc('Preparing downloads...');
  for (let i = 0; i < tracks.length; i++) {
    document.getElementById('processingText').textContent = `Encoding ${i+1} of ${tracks.length}...`;
    try {
      const wav = await trimAndEncode(tracks[i]);
      dlBlob(wav, 'TokPlay_' + sanitize(tracks[i].name) + '.wav');
    } catch(err) {
      dlBlob(tracks[i].blob, 'TokPlay_' + sanitize(tracks[i].name) + '.original');
    }
    // Small delay so downloads don't pile up
    await new Promise(r => setTimeout(r, 500));
  }
  hideProc();
  showToast(`${tracks.length} files saved to Downloads`, 'success');
}

function showProc(msg) { document.getElementById('processingOverlay').classList.add('show'); document.getElementById('processingText').textContent = msg; }
function hideProc() { document.getElementById('processingOverlay').classList.remove('show'); }

function deleteTrack(i, e) {
  e.stopPropagation();
  const wasPlaying = isPlaying && i === currentIndex;
  if (i === currentIndex) { audio.pause(); isPlaying = false; }
  if (tracks[i].url?.startsWith('blob:')) URL.revokeObjectURL(tracks[i].url);
  dbDelete(tracks[i].id); tracks.splice(i, 1);
  if (!tracks.length) {
    currentIndex=-1;
    document.getElementById('nowTitle').textContent='No track selected';
    document.getElementById('nowStatus').textContent='Upload videos to begin';
    document.getElementById('progressFill').style.width='0%';
    updatePlayBtn();
  } else if (i===currentIndex) {
    currentIndex=Math.min(i,tracks.length-1); loadTrack(currentIndex,wasPlaying);
  } else if (i<currentIndex) currentIndex--;
  renderTracks(); dbSaveMeta();
}

function showClearModal(){if(tracks.length)document.getElementById('clearModal').classList.add('show')}
function hideClearModal(){document.getElementById('clearModal').classList.remove('show')}
function clearPlaylist(){
  audio.pause();audio.src='';isPlaying=false;
  tracks.forEach(t=>{if(t.url?.startsWith('blob:'))URL.revokeObjectURL(t.url)});
  tracks=[];currentIndex=-1;
  document.getElementById('nowTitle').textContent='No track selected';
  document.getElementById('nowStatus').textContent='Upload videos to begin';
  document.getElementById('progressFill').style.width='0%';
  document.getElementById('currentTime').textContent='0:00';
  document.getElementById('totalTime').textContent='0:00';
  updatePlayBtn();renderTracks();dbClear();hideClearModal();
  showToast('Playlist cleared — TokPlay_ files in Downloads are safe','success');
}

// ─── Media Session ───
if ('mediaSession' in navigator) {
  navigator.mediaSession.setActionHandler('play',()=>togglePlay());
  navigator.mediaSession.setActionHandler('pause',()=>togglePlay());
  navigator.mediaSession.setActionHandler('previoustrack',()=>prevTrack());
  navigator.mediaSession.setActionHandler('nexttrack',()=>nextTrack());
  navigator.mediaSession.setActionHandler('seekto',d=>{if(d.seekTime!=null)audio.currentTime=d.seekTime});
}

function fmt(s){if(!s||isNaN(s))return'0:00';return`${Math.floor(s/60)}:${String(Math.floor(s%60)).padStart(2,'0')}`}

document.getElementById('clearModal').addEventListener('click',e=>{if(e.target===e.currentTarget)hideClearModal()});

// ─── Init ───
(async function(){
  try {
    const all = await dbLoadAll();
    const meta = all.find(x=>x.id==='__meta__');
    const data = all.filter(x=>x.id!=='__meta__');

    const ordered = [];
    if (meta?.order) {
      for (const id of meta.order) {
        const item = data.find(t=>t.id===id);
        if (item?.blob) {
          const url = URL.createObjectURL(item.blob);
          ordered.push({id:item.id,name:item.name,blob:item.blob,originalBlob:item.blob,url,fullDuration:item.duration,duration:item.trimmedDuration||item.duration,fromLibrary:item.trimmedDuration===item.duration});
        }
      }
      for (const item of data) {
        if (!ordered.find(t=>t.id===item.id)&&item.blob) {
          const url=URL.createObjectURL(item.blob);
          ordered.push({id:item.id,name:item.name,blob:item.blob,originalBlob:item.blob,url,fullDuration:item.duration,duration:item.trimmedDuration||item.duration,fromLibrary:false});
        }
      }
      currentIndex = meta.currentIndex >= 0 && meta.currentIndex < ordered.length ? meta.currentIndex : (ordered.length ? 0 : -1);
    } else {
      for (const item of data) {
        if (item.blob) {
          const url=URL.createObjectURL(item.blob);
          ordered.push({id:item.id,name:item.name,blob:item.blob,originalBlob:item.blob,url,fullDuration:item.duration,duration:item.trimmedDuration||item.duration,fromLibrary:false});
        }
      }
      if (ordered.length) currentIndex = 0;
    }

    tracks = ordered;
    renderTracks();
    if (currentIndex >= 0) loadTrack(currentIndex, false);
  } catch(e) { console.warn('Init error:', e); renderTracks(); }
})();
</script>
</body>
</html>
